//** BISMILLAHIR ROHMANIR ROHIM **
// 0-1 Kanpsack using top-down approach
/*
Input 1:
3 8
3 30
4 50
5 60
Output: 90

Input 2:
6 15
6 5
5 6
6 4
6 6
3 5
7 2
Output: 17
*/
#include <bits/stdc++.h>
using namespace std;

const char nl = '\n';
typedef vector<int> vi;

vector<vector<int>> dp;

int knapsak(int n, int w, vi weight, vi value)
{
    // Base case: no items or no remaining capacity
    if (n == 0 || w == 0)
    {
        return 0;
    }

    // If already computed, return stored value
    if (dp[n][w] != -1)
    {
        return dp[n][w];
    }

    // Can include the item
    if (weight[n] <= w)
    {
        int take = knapsak(n - 1, w - weight[n], weight, value) + value[n];
        int notTake = knapsak(n - 1, w, weight, value);

        return dp[n][w] = max(take, notTake);
    }
    else
    {
        int notTake = knapsak(n - 1, w, weight, value);
        return dp[n][w] = notTake;
    }
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n, w;
    cin >> n >> w;

    vi weight(n + 1);
    vi value(n + 1);

    dp.resize(n + 1, vi(w + 1, -1));

    for (int i = 1; i <= n; i++)
    {
        cin >> weight[i] >> value[i];
    }

    int res = knapsak(n, w, weight, value);

    cout << res << nl;
    return 0;
}
