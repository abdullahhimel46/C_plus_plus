//** BISMILLAHIR ROHMANIR ROHIM **
// 0-1 Kanpsack using top-down approach
/*
Input 1:
3 8
3 30
4 50
5 60
Output: 90

Input 2:
6 15
6 5
5 6
6 4
6 6
3 5
7 2
Output: 17
*/
#include <bits/stdc++.h>
using namespace std;

const char nl = '\n';
typedef vector<int> vi;
typedef pair<int, int> pii;
#define elif else if
#define all(x) x.begin(), x.end()
#define ll long long int // int=10e8,ll=10e18
#define py cout << "YES" << endl
#define pn cout << "NO" << endl
#define fori for (int i = 0; i < n; i++)
#define forj for (int j = 0; j < n; j++)

vector<vector<int>> dp;

int knapsak(int n, int w, vi weight, vi value)
{
    // Base case: no items or no remaining capacity
    if (n < 0 || w == 0)
    {
        return 0;
    }

    // If already computed, return stored value
    if (dp[n][w] != -1)
        return dp[n][w];

    // Can include the item
    if (weight[n] <= w) // bag e jaiga ase!!
    {
        // Include the item
        int include = knapsak(n - 1, w - weight[n], weight, value) + value[n];
        /* n-1 -> previous item */

        // Exclude the item
        int exclude = knapsak(n - 1, w, weight, value);

        return dp[n][w] = max(include, exclude); // Take the maximum value
    }
    else
    {
        // weight[n] > w: Can't include the item, so skip it
        int exclude = knapsak(n - 1, w, weight, value); 
        return dp[n][w];
    }

    /*
    Visualization:
    inside the knapsak fn, received n=2:
    index ->  0  1  2
    weight = {3, 4, 5}
    w = 8

    Step 1: knapsak(2, 8)
    Look at the 3rd item (weight = 5, value = 60).
    Two options:
        Include it: knapsak(2, 3) + 60
        (Reduce the capacity to 8-5=3, and consider the first 2 items.)
        Exclude it: knapsak(2, 8)
        (Keep the full capacity and consider the first 2 items.)
    Step 2: knapsak(1, 3)
    Look at the 2nd item (weight = 4, value = 50).
    Two options:
        Include it: Not possible because weight[1] > 3.
        Exclude it: knapsak(1, 3)
    */
}

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);

    int n, w;
    cin >> n >> w;
    vi weight(n);
    vi value(n);

    dp.resize(n + 1, vi(w + 1, -1));

    for (int i = 0; i < n; i++)
    {
        cin >> weight[i] >> value[i];
    }

    int res = knapsak(n - 1, w, weight, value);
    // n-1 -> for 0-based indexing
    /*
    n=3:
    index ->  0  1  2
    weight = {3, 4, 5}
    */

    cout << res << nl;
    return 0;
}
